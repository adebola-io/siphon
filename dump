// organize() {
  //   var newToken: Token;
  //   var previous: Token | undefined;
  //   // 1. Member Expressions.
  //   for (let t = 0; this.tokens[t]; t++) {
  //     if (this.tokens[t].raw === ".") {
  //       previous = this.tokens[t - 1];
  //       newToken = {
  //         type: "MemberExpression",
  //         start: previous?.start ?? 0,
  //         end: this.tokens[t + 1].end,
  //         raw: (previous?.raw ?? "") + "." + (this.tokens[t + 1].raw ?? ""),
  //         details: {
  //           object: previous,
  //           property: this.tokens[t + 1],
  //         },
  //       };
  //       this.tokens.splice(t - 1, 3, newToken);
  //       t -= 2;
  //     }
  //   }
  //   //2.  Numeric Operators.
  //   for (let u = 0; this.tokens[u]; u++) {
  //     switch (this.tokens[u].raw) {
  //       case "-":
  //       case "+":
  //         if (
  //           !this.tokens[u - 1] ||
  //           !["UnaryExpression", "Number", "BinaryExpression"].includes(
  //             this.tokens[u - 1].type ?? ""
  //           )
  //         ) {
  //           newToken = {
  //             type: "UnaryExpression",
  //             start: this.tokens[u].start,
  //             end: this.tokens[u + 1].end,
  //             raw: this.tokens[u].raw + (this.tokens[u + 1].raw ?? ""),
  //             details: {
  //               operator: this.tokens[u].raw,
  //               prefix: true,
  //               argument: this.tokens[u + 1],
  //             },
  //           };
  //           this.tokens.splice(u, 2, newToken);
  //           u++;
  //           break;
  //         }
  //       case "*":
  //       case "%":
  //       case "/":
  //       case "&":
  //       case "|":
  //       case "^":
  //       case "<<":
  //       case ">>":
  //         previous = this.tokens[u - 1];
  //         newToken = {
  //           type: "BinaryExpression",
  //           start: previous.start,
  //           end: this.tokens[u + 1].end,
  //           raw:
  //             previous.raw +
  //             " " +
  //             this.tokens[u].raw +
  //             " " +
  //             this.tokens[u + 1].raw,
  //           details: {
  //             operator: this.tokens[u].raw,
  //             left: previous,
  //             right: this.tokens[u + 1],
  //           },
  //         };
  //         this.tokens.splice(u - 1, 3, newToken);
  //         u -= 2;
  //         break;
  //     }
  //   }
  //   // 3. Function Calls.
  //   for (let v = 0; this.tokens[v]; v++) {
  //     if (
  //       this.tokens[v].type === "Group" &&
  //       ["MemberExpression", "Identifier", "Group"].includes(
  //         this.tokens[v - 1].type ?? ""
  //       )
  //     ) {
  //       previous = this.tokens[v - 1];
  //       newToken = {
  //         type: "CallExpression",
  //         start: previous.start,
  //         end: this.tokens[v].end,
  //         raw: previous.raw + (this.tokens[v].raw ?? ""),
  //         details: {
  //           callee: previous,
  //           arguments: this.tokens[v].details.inner,
  //         },
  //       };
  //       this.tokens.splice(v - 1, 2, newToken);
  //       v--;
  //     }
  //   }
  //   // 4. Variable Declarations.
  //   for (let w = 0; this.tokens[w]; w++) {
  //     if (declarators.includes(this.tokens[w].raw ?? "")) {
  //       newToken = {
  //         type: "VariableDeclaration",
  //         start: this.tokens[w].start,
  //         details: {
  //           var_type: this.tokens[w].raw,
  //           declarations: [],
  //         },
  //         raw: this.tokens[w].raw,
  //       };
  //       let toslice = this.declareVariables(w, newToken);
  //       this.tokens.splice(w, toslice, newToken);
  //       w -= toslice - 1;
  //     }
  //   }
  //   // 5. Assignment Expressions.
  //   for (let x = 0; this.tokens[x]; x++) {
  //     if (this.tokens[x].raw === "=") {
  //       previous = this.tokens[x - 1];
  //       if (!previous) {
  //         Errors.enc(
  //           "VARIABLE_DECLARATION_EXPECTED",
  //           this.sourceFile,
  //           this.tokens[x].start
  //         );
  //       } else if (previous.type === "CallExpression") {
  //         Errors.enc(
  //           "INVALID_ASSIGNMENT_LEFT",
  //           this.sourceFile,
  //           previous.start
  //         );
  //       }
  //       newToken = {
  //         type: "AssignmentExpression",
  //         start: previous.start,
  //         end: this.tokens[x + 1].end,
  //         raw: previous.raw + " = " + this.tokens[x + 1].raw,
  //         details: {
  //           operator: "=",
  //           left: previous,
  //           right: this.tokens[x + 1],
  //         },
  //       };
  //       this.tokens.splice(x - 1, 3, newToken);
  //       x -= 2;
  //     }
  //   }
  // }