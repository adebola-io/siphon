const {Task}=require("../lib/structures");const a=require("../lib");const {siphonOptions}=require("../lib/types");const {existsSync}=require("fs");const {getFileName}=require("../lib/utils");const {resolve}=require("path");const {green,bold}=require("colors");const b=new Task(process.argv);const c=require("./start");const d=require("path");var e;if(existsSync("siphon.config.js")){e={...(a.defaults),...require(resolve("siphon.config.js"))};}else e=a.defaults;switch(true){case (b.args.watch||b.args.w)&&(b.inputs.includes("-bundle")||b.inputs.includes("-b"))&&b.inputs.length===1:a.watcher(e);break;case b.inputs.length===2&&(b.inputs[0]==="-bundle"||b.inputs[0]==="-b"):a.bundler(b.inputs[1]).into(e.outDir+"/"+getFileName(b.inputs[1])+".html",e);console.log();console.log(bold(green("Bundled "+b.inputs[1]+" successfully.")));break;case b.inputs.length===3&&(b.inputs[0]==="-bundle"||b.inputs[0]==="-b"):e.outDir=b.inputs[2].split(/\//).slice(0,-1).join("/");a.bundler(b.inputs[1]).into(b.inputs[2],e);console.log();console.log(bold(green("Bundled "+b.inputs[1]+" successfully.")));break;case b.inputs.includes("-bundle")||b.inputs.includes("-b"):e.relations.forEach((relation)=>{var f=`${e.rootDir}/${relation.from}`;var g=("").concat(e.outDir,"/").concat(relation.to);a.bundler(f).into(g,e);console.log();console.log(bold(green(" Bundling successful. Siphon found zero errors.")));});break;default:console.log(c);break;}